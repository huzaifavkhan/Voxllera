{"version":3,"file":"lib.modern.js","sources":["../src/BaseConversation.ts","../src/utils/BaseConnection.ts","../src/utils/events.ts","../src/utils/overrides.ts","../src/utils/WebSocketConnection.ts","../src/utils/WebRTCConnection.ts","../src/utils/ConnectionFactory.ts","../src/utils/compatibility.ts","../src/utils/applyDelay.ts","../src/TextConversation.ts","../src/utils/audio.ts","../src/utils/createWorkletModuleLoader.ts","../src/utils/rawAudioProcessor.ts","../src/utils/input.ts","../src/utils/audioConcatProcessor.ts","../src/utils/output.ts","../src/VoiceConversation.ts","../src/utils/postOverallFeedback.ts","../src/index.ts"],"sourcesContent":["import type {\n  BaseConnection,\n  DisconnectionDetails,\n  OnDisconnectCallback,\n  SessionConfig,\n} from \"./utils/BaseConnection\";\nimport type {\n  AgentAudioEvent,\n  AgentResponseEvent,\n  ClientToolCallEvent,\n  IncomingSocketEvent,\n  InternalTentativeAgentResponseEvent,\n  InterruptionEvent,\n  UserTranscriptionEvent,\n} from \"./utils/events\";\nimport type { InputConfig } from \"./utils/input\";\n\nexport type Role = \"user\" | \"ai\";\n\nexport type Mode = \"speaking\" | \"listening\";\n\nexport type Status =\n  | \"connecting\"\n  | \"connected\"\n  | \"disconnecting\"\n  | \"disconnected\";\n\nexport type Options = SessionConfig &\n  Callbacks &\n  ClientToolsConfig &\n  InputConfig;\n\nexport type PartialOptions = SessionConfig &\n  Partial<Callbacks> &\n  Partial<ClientToolsConfig> &\n  Partial<InputConfig>;\n\nexport type ClientToolsConfig = {\n  clientTools: Record<\n    string,\n    (\n      parameters: any\n    ) => Promise<string | number | void> | string | number | void\n  >;\n};\n\nexport type Callbacks = {\n  onConnect: (props: { conversationId: string }) => void;\n  // internal debug events, not to be used\n  onDebug: (props: any) => void;\n  onDisconnect: OnDisconnectCallback;\n  onError: (message: string, context?: any) => void;\n  onMessage: (props: { message: string; source: Role }) => void;\n  onAudio: (base64Audio: string) => void;\n  onModeChange: (prop: { mode: Mode }) => void;\n  onStatusChange: (prop: { status: Status }) => void;\n  onCanSendFeedbackChange: (prop: { canSendFeedback: boolean }) => void;\n  onUnhandledClientToolCall?: (\n    params: ClientToolCallEvent[\"client_tool_call\"]\n  ) => void;\n};\n\nconst EMPTY_FREQUENCY_DATA = new Uint8Array(0);\n\nexport class BaseConversation {\n  protected lastInterruptTimestamp = 0;\n  protected mode: Mode = \"listening\";\n  protected status: Status = \"connecting\";\n  protected volume = 1;\n  protected currentEventId = 1;\n  protected lastFeedbackEventId = 1;\n  protected canSendFeedback = false;\n\n  protected static getFullOptions(partialOptions: PartialOptions): Options {\n    return {\n      clientTools: {},\n      onConnect: () => {},\n      onDebug: () => {},\n      onDisconnect: () => {},\n      onError: () => {},\n      onMessage: () => {},\n      onAudio: () => {},\n      onModeChange: () => {},\n      onStatusChange: () => {},\n      onCanSendFeedbackChange: () => {},\n      ...partialOptions,\n    };\n  }\n\n  protected constructor(\n    protected readonly options: Options,\n    protected readonly connection: BaseConnection\n  ) {\n    this.options.onConnect({ conversationId: connection.conversationId });\n    this.connection.onMessage(this.onMessage);\n    this.connection.onDisconnect(this.endSessionWithDetails);\n    this.updateStatus(\"connected\");\n  }\n\n  public endSession() {\n    return this.endSessionWithDetails({ reason: \"user\" });\n  }\n\n  private endSessionWithDetails = async (details: DisconnectionDetails) => {\n    if (this.status !== \"connected\" && this.status !== \"connecting\") return;\n    this.updateStatus(\"disconnecting\");\n    await this.handleEndSession();\n    this.updateStatus(\"disconnected\");\n    this.options.onDisconnect(details);\n  };\n\n  protected async handleEndSession() {\n    this.connection.close();\n  }\n\n  protected updateMode(mode: Mode) {\n    if (mode !== this.mode) {\n      this.mode = mode;\n      this.options.onModeChange({ mode });\n    }\n  }\n\n  protected updateStatus(status: Status) {\n    if (status !== this.status) {\n      this.status = status;\n      this.options.onStatusChange({ status });\n    }\n  }\n\n  protected updateCanSendFeedback() {\n    const canSendFeedback = this.currentEventId !== this.lastFeedbackEventId;\n    if (this.canSendFeedback !== canSendFeedback) {\n      this.canSendFeedback = canSendFeedback;\n      this.options.onCanSendFeedbackChange({ canSendFeedback });\n    }\n  }\n\n  protected handleInterruption(event: InterruptionEvent) {\n    if (event.interruption_event) {\n      this.lastInterruptTimestamp = event.interruption_event.event_id;\n    }\n  }\n\n  protected handleAgentResponse(event: AgentResponseEvent) {\n    this.options.onMessage({\n      source: \"ai\",\n      message: event.agent_response_event.agent_response,\n    });\n  }\n\n  protected handleUserTranscript(event: UserTranscriptionEvent) {\n    this.options.onMessage({\n      source: \"user\",\n      message: event.user_transcription_event.user_transcript,\n    });\n  }\n\n  protected handleTentativeAgentResponse(\n    event: InternalTentativeAgentResponseEvent\n  ) {\n    this.options.onDebug({\n      type: \"tentative_agent_response\",\n      response:\n        event.tentative_agent_response_internal_event.tentative_agent_response,\n    });\n  }\n\n  protected async handleClientToolCall(event: ClientToolCallEvent) {\n    if (\n      Object.prototype.hasOwnProperty.call(\n        this.options.clientTools,\n        event.client_tool_call.tool_name\n      )\n    ) {\n      try {\n        const result =\n          (await this.options.clientTools[event.client_tool_call.tool_name](\n            event.client_tool_call.parameters\n          )) ?? \"Client tool execution successful.\"; // default client-tool call response\n\n        // The API expects result to be a string, so we need to convert it if it's not already a string\n        const formattedResult =\n          typeof result === \"object\" ? JSON.stringify(result) : String(result);\n\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: formattedResult,\n          is_error: false,\n        });\n      } catch (e) {\n        this.onError(\n          `Client tool execution failed with following error: ${(e as Error)?.message}`,\n          {\n            clientToolName: event.client_tool_call.tool_name,\n          }\n        );\n        this.connection.sendMessage({\n          type: \"client_tool_result\",\n          tool_call_id: event.client_tool_call.tool_call_id,\n          result: `Client tool execution failed: ${(e as Error)?.message}`,\n          is_error: true,\n        });\n      }\n    } else {\n      if (this.options.onUnhandledClientToolCall) {\n        this.options.onUnhandledClientToolCall(event.client_tool_call);\n\n        return;\n      }\n\n      this.onError(\n        `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        {\n          clientToolName: event.client_tool_call.tool_name,\n        }\n      );\n      this.connection.sendMessage({\n        type: \"client_tool_result\",\n        tool_call_id: event.client_tool_call.tool_call_id,\n        result: `Client tool with name ${event.client_tool_call.tool_name} is not defined on client`,\n        is_error: true,\n      });\n    }\n  }\n\n  protected handleAudio(event: AgentAudioEvent) {}\n\n  private onMessage = async (parsedEvent: IncomingSocketEvent) => {\n    switch (parsedEvent.type) {\n      case \"interruption\": {\n        this.handleInterruption(parsedEvent);\n        return;\n      }\n      case \"agent_response\": {\n        this.handleAgentResponse(parsedEvent);\n        return;\n      }\n      case \"user_transcript\": {\n        this.handleUserTranscript(parsedEvent);\n        return;\n      }\n      case \"internal_tentative_agent_response\": {\n        this.handleTentativeAgentResponse(parsedEvent);\n        return;\n      }\n      case \"client_tool_call\": {\n        await this.handleClientToolCall(parsedEvent);\n        return;\n      }\n      case \"audio\": {\n        this.handleAudio(parsedEvent);\n        return;\n      }\n\n      case \"ping\": {\n        this.connection.sendMessage({\n          type: \"pong\",\n          event_id: parsedEvent.ping_event.event_id,\n        });\n        // parsedEvent.ping_event.ping_ms can be used on client side, for example\n        // to warn if ping is too high that experience might be degraded.\n        return;\n      }\n\n      // unhandled events are expected to be internal events\n      default: {\n        this.options.onDebug(parsedEvent);\n        return;\n      }\n    }\n  };\n\n  private onError(message: string, context?: any) {\n    console.error(message, context);\n    this.options.onError(message, context);\n  }\n\n  public getId() {\n    return this.connection.conversationId;\n  }\n\n  public isOpen() {\n    return this.status === \"connected\";\n  }\n\n  public setVolume = ({ volume }: { volume: number }) => {\n    this.volume = volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {}\n\n  public getInputByteFrequencyData() {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getOutputByteFrequencyData() {\n    return EMPTY_FREQUENCY_DATA;\n  }\n\n  public getInputVolume() {\n    return 0;\n  }\n\n  public getOutputVolume() {\n    return 0;\n  }\n\n  public sendFeedback(like: boolean) {\n    if (!this.canSendFeedback) {\n      console.warn(\n        this.lastFeedbackEventId === 0\n          ? \"Cannot send feedback: the conversation has not started yet.\"\n          : \"Cannot send feedback: feedback has already been sent for the current response.\"\n      );\n      return;\n    }\n\n    this.connection.sendMessage({\n      type: \"feedback\",\n      score: like ? \"like\" : \"dislike\",\n      event_id: this.currentEventId,\n    });\n    this.lastFeedbackEventId = this.currentEventId;\n    this.updateCanSendFeedback();\n  }\n\n  public sendContextualUpdate(text: string) {\n    this.connection.sendMessage({\n      type: \"contextual_update\",\n      text,\n    });\n  }\n\n  public sendUserMessage(text: string) {\n    this.connection.sendMessage({\n      type: \"user_message\",\n      text,\n    });\n  }\n\n  public sendUserActivity() {\n    this.connection.sendMessage({\n      type: \"user_activity\",\n    });\n  }\n\n  public sendMCPToolApprovalResult(toolCallId: string, isApproved: boolean) {\n    this.connection.sendMessage({\n      type: \"mcp_tool_approval_result\",\n      tool_call_id: toolCallId,\n      is_approved: isApproved,\n    });\n  }\n}\n","import type { IncomingSocketEvent, OutgoingSocketEvent } from \"./events\";\n\nexport type Language =\n  | \"en\"\n  | \"ja\"\n  | \"zh\"\n  | \"de\"\n  | \"hi\"\n  | \"fr\"\n  | \"ko\"\n  | \"pt\"\n  | \"pt-br\"\n  | \"it\"\n  | \"es\"\n  | \"id\"\n  | \"nl\"\n  | \"tr\"\n  | \"pl\"\n  | \"sv\"\n  | \"bg\"\n  | \"ro\"\n  | \"ar\"\n  | \"cs\"\n  | \"el\"\n  | \"fi\"\n  | \"ms\"\n  | \"da\"\n  | \"ta\"\n  | \"uk\"\n  | \"ru\"\n  | \"hu\"\n  | \"hr\"\n  | \"sk\"\n  | \"no\"\n  | \"vi\";\n\nexport type DelayConfig = {\n  default: number;\n  android?: number;\n  ios?: number;\n};\n\nexport type FormatConfig = {\n  format: \"pcm\" | \"ulaw\";\n  sampleRate: number;\n};\n\nexport type DisconnectionDetails =\n  | {\n      reason: \"error\";\n      message: string;\n      context: Event;\n    }\n  | {\n      reason: \"agent\";\n      context: CloseEvent;\n    }\n  | {\n      reason: \"user\";\n    };\n\nexport type OnDisconnectCallback = (details: DisconnectionDetails) => void;\nexport type OnMessageCallback = (event: IncomingSocketEvent) => void;\n\nexport type BaseSessionConfig = {\n  origin?: string;\n  authorization?: string;\n  livekitUrl?: string;\n  overrides?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      firstMessage?: string;\n      language?: Language;\n    };\n    tts?: {\n      voiceId?: string;\n    };\n    conversation?: {\n      textOnly?: boolean;\n    };\n  };\n  customLlmExtraBody?: unknown;\n  dynamicVariables?: Record<string, string | number | boolean>;\n  useWakeLock?: boolean;\n  connectionDelay?: DelayConfig;\n  textOnly?: boolean;\n  connectionType?: ConnectionType;\n  userId?: string;\n};\n\nexport type ConnectionType = \"websocket\" | \"webrtc\";\n\nexport type SessionConfig = BaseSessionConfig & {\n  agentId?: string;\n  signedUrl?: string;\n  conversationToken?: string;\n};\n\nexport abstract class BaseConnection {\n  public abstract readonly conversationId: string;\n  public abstract readonly inputFormat: FormatConfig;\n  public abstract readonly outputFormat: FormatConfig;\n\n  protected queue: IncomingSocketEvent[] = [];\n  protected disconnectionDetails: DisconnectionDetails | null = null;\n  protected onDisconnectCallback: OnDisconnectCallback | null = null;\n  protected onMessageCallback: OnMessageCallback | null = null;\n  protected onDebug?: (info: unknown) => void;\n\n  constructor(config: { onDebug?: (info: unknown) => void } = {}) {\n    this.onDebug = config.onDebug;\n  }\n\n  protected debug(info: unknown) {\n    if (this.onDebug) this.onDebug(info);\n  }\n\n  public abstract close(): void;\n  public abstract sendMessage(message: OutgoingSocketEvent): void;\n\n  public onMessage(callback: OnMessageCallback) {\n    this.onMessageCallback = callback;\n    const queue = this.queue;\n    this.queue = [];\n\n    if (queue.length > 0) {\n      // Make sure the queue is flushed after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        queue.forEach(callback);\n      });\n    }\n  }\n\n  public onDisconnect(callback: OnDisconnectCallback) {\n    this.onDisconnectCallback = callback;\n    const details = this.disconnectionDetails;\n    if (details) {\n      // Make sure the event is triggered after the constructors finishes and\n      // classes are initialized.\n      queueMicrotask(() => {\n        callback(details);\n      });\n    }\n  }\n\n  protected disconnect(details: DisconnectionDetails) {\n    if (!this.disconnectionDetails) {\n      this.disconnectionDetails = details;\n      this.onDisconnectCallback?.(details);\n    }\n  }\n\n  protected handleMessage(parsedEvent: IncomingSocketEvent) {\n    if (this.onMessageCallback) {\n      this.onMessageCallback(parsedEvent);\n    } else {\n      this.queue.push(parsedEvent);\n    }\n  }\n}\n\nexport function parseFormat(format: string): FormatConfig {\n  const [formatPart, sampleRatePart] = format.split(\"_\");\n  if (![\"pcm\", \"ulaw\"].includes(formatPart)) {\n    throw new Error(`Invalid format: ${format}`);\n  }\n\n  const sampleRate = Number.parseInt(sampleRatePart);\n  if (Number.isNaN(sampleRate)) {\n    throw new Error(`Invalid sample rate: ${sampleRatePart}`);\n  }\n\n  return {\n    format: formatPart as FormatConfig[\"format\"],\n    sampleRate,\n  };\n}\n","import type { Language } from \"./connection\";\nimport type { CONVERSATION_INITIATION_CLIENT_DATA_TYPE } from \"./overrides\";\n\nexport type UserTranscriptionEvent = {\n  type: \"user_transcript\";\n  user_transcription_event: { user_transcript: string };\n};\nexport type AgentResponseEvent = {\n  type: \"agent_response\";\n  agent_response_event: { agent_response: string };\n};\nexport type AgentAudioEvent = {\n  type: \"audio\";\n  audio_event: {\n    audio_base_64: string;\n    event_id: number;\n  };\n};\nexport type InterruptionEvent = {\n  type: \"interruption\";\n  interruption_event: {\n    event_id: number;\n  };\n};\nexport type InternalTentativeAgentResponseEvent = {\n  type: \"internal_tentative_agent_response\";\n  tentative_agent_response_internal_event: {\n    tentative_agent_response: string;\n  };\n};\nexport type ConfigEvent = {\n  type: \"conversation_initiation_metadata\";\n  conversation_initiation_metadata_event: {\n    conversation_id: string;\n    agent_output_audio_format: string;\n    user_input_audio_format?: string;\n  };\n};\nexport type PingEvent = {\n  type: \"ping\";\n  ping_event: {\n    event_id: number;\n    ping_ms?: number;\n  };\n};\nexport type ClientToolCallEvent = {\n  type: \"client_tool_call\";\n  client_tool_call: {\n    tool_name: string;\n    tool_call_id: string;\n    parameters: any;\n    expects_response: boolean;\n  };\n};\n\n// TODO correction missing\nexport type IncomingSocketEvent =\n  | UserTranscriptionEvent\n  | AgentResponseEvent\n  | AgentAudioEvent\n  | InterruptionEvent\n  | InternalTentativeAgentResponseEvent\n  | ConfigEvent\n  | PingEvent\n  | ClientToolCallEvent;\n\nexport type PongEvent = {\n  type: \"pong\";\n  event_id: number;\n};\nexport type UserAudioEvent = {\n  user_audio_chunk: string;\n};\nexport type UserFeedbackEvent = {\n  type: \"feedback\";\n  score: \"like\" | \"dislike\";\n  event_id: number;\n};\nexport type ClientToolResultEvent = {\n  type: \"client_tool_result\";\n  tool_call_id: string;\n  result: any;\n  is_error: boolean;\n};\nexport type InitiationClientDataEvent = {\n  type: typeof CONVERSATION_INITIATION_CLIENT_DATA_TYPE;\n  conversation_config_override?: {\n    agent?: {\n      prompt?: {\n        prompt?: string;\n      };\n      first_message?: string;\n      language?: Language;\n    };\n    tts?: {\n      voice_id?: string;\n    };\n    conversation?: {\n      text_only?: boolean;\n    };\n  };\n  custom_llm_extra_body?: any;\n  dynamic_variables?: Record<string, string | number | boolean>;\n  user_id?: string;\n};\nexport type ContextualUpdateEvent = {\n  type: \"contextual_update\";\n  text: string;\n};\nexport type UserMessageEvent = {\n  type: \"user_message\";\n  text: string;\n};\nexport type UserActivityEvent = {\n  type: \"user_activity\";\n};\nexport type MCPToolApprovalResultEvent = {\n  type: \"mcp_tool_approval_result\";\n  tool_call_id: string;\n  is_approved: boolean;\n};\nexport type OutgoingSocketEvent =\n  | PongEvent\n  | UserAudioEvent\n  | InitiationClientDataEvent\n  | UserFeedbackEvent\n  | ClientToolResultEvent\n  | ContextualUpdateEvent\n  | UserMessageEvent\n  | UserActivityEvent\n  | MCPToolApprovalResultEvent;\n\nexport function isValidSocketEvent(event: any): event is IncomingSocketEvent {\n  return !!event.type;\n}\n","import type { SessionConfig } from \"./BaseConnection\";\nimport type { InitiationClientDataEvent } from \"./events\";\n\nexport const CONVERSATION_INITIATION_CLIENT_DATA_TYPE =\n  \"conversation_initiation_client_data\";\n\nexport function constructOverrides(\n  config: SessionConfig\n): InitiationClientDataEvent {\n  const overridesEvent: InitiationClientDataEvent = {\n    type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n  };\n\n  if (config.overrides) {\n    overridesEvent.conversation_config_override = {\n      agent: {\n        prompt: config.overrides.agent?.prompt,\n        first_message: config.overrides.agent?.firstMessage,\n        language: config.overrides.agent?.language,\n      },\n      tts: {\n        voice_id: config.overrides.tts?.voiceId,\n      },\n      conversation: {\n        text_only: config.overrides.conversation?.textOnly,\n      },\n    };\n  }\n\n  if (config.customLlmExtraBody) {\n    overridesEvent.custom_llm_extra_body = config.customLlmExtraBody;\n  }\n\n  if (config.dynamicVariables) {\n    overridesEvent.dynamic_variables = config.dynamicVariables;\n  }\n\n  if (config.userId) {\n    overridesEvent.user_id = config.userId;\n  }\n\n  return overridesEvent;\n}\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport {\n  type ConfigEvent,\n  isValidSocketEvent,\n  type OutgoingSocketEvent,\n} from \"./events\";\nimport { constructOverrides } from \"./overrides\";\n\nconst MAIN_PROTOCOL = \"convai\";\nconst WSS_API_ORIGIN = \"wss://api.elevenlabs.io\";\nconst WSS_API_PATHNAME = \"/v1/convai/conversation?agent_id=\";\n\nexport class WebSocketConnection extends BaseConnection {\n  public readonly conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private constructor(\n    private readonly socket: WebSocket,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig\n  ) {\n    super();\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.socket.addEventListener(\"error\", event => {\n      // In case the error event is followed by a close event, we want the\n      // latter to be the one that disconnects the session as it contains more\n      // useful information.\n      setTimeout(\n        () =>\n          this.disconnect({\n            reason: \"error\",\n            message: \"The connection was closed due to a socket error.\",\n            context: event,\n          }),\n        0\n      );\n    });\n\n    this.socket.addEventListener(\"close\", event => {\n      this.disconnect(\n        event.code === 1000\n          ? {\n              reason: \"agent\",\n              context: event,\n            }\n          : {\n              reason: \"error\",\n              message:\n                event.reason || \"The connection was closed by the server.\",\n              context: event,\n            }\n      );\n    });\n\n    this.socket.addEventListener(\"message\", event => {\n      try {\n        const parsedEvent = JSON.parse(event.data);\n        if (!isValidSocketEvent(parsedEvent)) {\n          return;\n        }\n        this.handleMessage(parsedEvent);\n      } catch (_) {}\n    });\n  }\n\n  public static async create(\n    config: SessionConfig\n  ): Promise<WebSocketConnection> {\n    let socket: WebSocket | null = null;\n\n    try {\n      const origin = config.origin ?? WSS_API_ORIGIN;\n      const url = config.signedUrl\n        ? config.signedUrl\n        : origin + WSS_API_PATHNAME + config.agentId;\n\n      const protocols = [MAIN_PROTOCOL];\n      if (config.authorization) {\n        protocols.push(`bearer.${config.authorization}`);\n      }\n      socket = new WebSocket(url, protocols);\n\n      const conversationConfig = await new Promise<\n        ConfigEvent[\"conversation_initiation_metadata_event\"]\n      >((resolve, reject) => {\n        socket!.addEventListener(\n          \"open\",\n          () => {\n            const overridesEvent = constructOverrides(config);\n\n            socket?.send(JSON.stringify(overridesEvent));\n          },\n          { once: true }\n        );\n\n        socket!.addEventListener(\"error\", event => {\n          // In case the error event is followed by a close event, we want the\n          // latter to be the one that rejects the promise as it contains more\n          // useful information.\n          setTimeout(() => reject(event), 0);\n        });\n\n        socket!.addEventListener(\"close\", reject);\n\n        socket!.addEventListener(\n          \"message\",\n          (event: MessageEvent) => {\n            const message = JSON.parse(event.data);\n\n            if (!isValidSocketEvent(message)) {\n              return;\n            }\n\n            if (message.type === \"conversation_initiation_metadata\") {\n              resolve(message.conversation_initiation_metadata_event);\n            } else {\n              console.warn(\n                \"First received message is not conversation metadata.\"\n              );\n            }\n          },\n          { once: true }\n        );\n      });\n\n      const {\n        conversation_id,\n        agent_output_audio_format,\n        user_input_audio_format,\n      } = conversationConfig;\n\n      const inputFormat = parseFormat(user_input_audio_format ?? \"pcm_16000\");\n      const outputFormat = parseFormat(agent_output_audio_format);\n\n      return new WebSocketConnection(\n        socket,\n        conversation_id,\n        inputFormat,\n        outputFormat\n      );\n    } catch (error) {\n      socket?.close();\n      throw error;\n    }\n  }\n\n  public close() {\n    this.socket.close();\n  }\n\n  public sendMessage(message: OutgoingSocketEvent) {\n    this.socket.send(JSON.stringify(message));\n  }\n}\n","import {\n  BaseConnection,\n  type SessionConfig,\n  type FormatConfig,\n  parseFormat,\n} from \"./BaseConnection\";\nimport { isValidSocketEvent, type OutgoingSocketEvent } from \"./events\";\nimport { Room, RoomEvent, Track, ConnectionState } from \"livekit-client\";\nimport type {\n  RemoteAudioTrack,\n  Participant,\n  TrackPublication,\n} from \"livekit-client\";\nimport {\n  constructOverrides,\n  CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n} from \"./overrides\";\n\nconst DEFAULT_LIVEKIT_WS_URL = \"wss://livekit.rtc.elevenlabs.io\";\n\nexport type ConnectionConfig = SessionConfig & {\n  onDebug?: (info: unknown) => void;\n};\n\nexport class WebRTCConnection extends BaseConnection {\n  public conversationId: string;\n  public readonly inputFormat: FormatConfig;\n  public readonly outputFormat: FormatConfig;\n\n  private room: Room;\n  private isConnected = false;\n\n  private constructor(\n    room: Room,\n    conversationId: string,\n    inputFormat: FormatConfig,\n    outputFormat: FormatConfig,\n    config: { onDebug?: (info: unknown) => void } = {}\n  ) {\n    super(config);\n    this.room = room;\n    this.conversationId = conversationId;\n    this.inputFormat = inputFormat;\n    this.outputFormat = outputFormat;\n\n    this.setupRoomEventListeners();\n  }\n\n  public static async create(\n    config: ConnectionConfig\n  ): Promise<WebRTCConnection> {\n    let conversationToken: string;\n\n    // Handle different authentication scenarios\n    if (\"conversationToken\" in config && config.conversationToken) {\n      // Direct token provided\n      conversationToken = config.conversationToken;\n    } else if (\"agentId\" in config && config.agentId) {\n      // Agent ID provided - fetch token from API\n      try {\n        const response = await fetch(\n          `https://api.elevenlabs.io/v1/convai/conversation/token?agent_id=${config.agentId}`\n        );\n\n        if (!response.ok) {\n          throw new Error(\n            `ElevenLabs API returned ${response.status} ${response.statusText}`\n          );\n        }\n\n        const data = await response.json();\n        conversationToken = data.token;\n\n        if (!conversationToken) {\n          throw new Error(\"No conversation token received from API\");\n        }\n      } catch (error) {\n        let msg = error instanceof Error ? error.message : String(error);\n        if (error instanceof Error && error.message.includes(\"401\")) {\n          msg =\n            \"Your agent has authentication enabled, but no signed URL or conversation token was provided.\";\n        }\n\n        throw new Error(\n          `Failed to fetch conversation token for agent ${config.agentId}: ${msg}`\n        );\n      }\n    } else {\n      throw new Error(\n        \"Either conversationToken or agentId is required for WebRTC connection\"\n      );\n    }\n\n    const room = new Room();\n\n    try {\n      // Create connection instance first to set up event listeners\n      const conversationId = `webrtc-${Date.now()}`;\n      const inputFormat = parseFormat(\"pcm_48000\");\n      const outputFormat = parseFormat(\"pcm_48000\");\n      const connection = new WebRTCConnection(\n        room,\n        conversationId,\n        inputFormat,\n        outputFormat,\n        config\n      );\n\n      // Use configurable LiveKit URL or default if not provided\n      const livekitUrl = config.livekitUrl || DEFAULT_LIVEKIT_WS_URL;\n\n      // Connect to the LiveKit room and wait for the Connected event\n      await room.connect(livekitUrl, conversationToken);\n\n      // Wait for the Connected event to ensure isConnected is true\n      await new Promise<void>(resolve => {\n        if (connection.isConnected) {\n          resolve();\n        } else {\n          const onConnected = () => {\n            room.off(RoomEvent.Connected, onConnected);\n            resolve();\n          };\n          room.on(RoomEvent.Connected, onConnected);\n        }\n      });\n\n      // Update conversation ID with actual room name if available\n      if (room.name) {\n        connection.conversationId = room.name;\n      }\n\n      // Enable microphone and send overrides\n      await room.localParticipant.setMicrophoneEnabled(true);\n\n      const overridesEvent = constructOverrides(config);\n\n      connection.debug({\n        type: CONVERSATION_INITIATION_CLIENT_DATA_TYPE,\n        message: overridesEvent,\n      });\n\n      await connection.sendMessage(overridesEvent);\n\n      return connection;\n    } catch (error) {\n      await room.disconnect();\n      throw error;\n    }\n  }\n\n  private setupRoomEventListeners() {\n    this.room.on(RoomEvent.Connected, async () => {\n      this.isConnected = true;\n      console.info(\"WebRTC room connected\");\n    });\n\n    this.room.on(RoomEvent.Disconnected, reason => {\n      this.isConnected = false;\n      this.disconnect({\n        reason: \"agent\",\n        context: new CloseEvent(\"close\", { reason: reason?.toString() }),\n      });\n    });\n\n    this.room.on(RoomEvent.ConnectionStateChanged, state => {\n      if (state === ConnectionState.Disconnected) {\n        this.isConnected = false;\n        this.disconnect({\n          reason: \"error\",\n          message: `LiveKit connection state changed to ${state}`,\n          context: new Event(\"connection_state_changed\"),\n        });\n      }\n    });\n\n    // Handle incoming data messages\n    this.room.on(RoomEvent.DataReceived, (payload: Uint8Array, participant) => {\n      try {\n        const message = JSON.parse(new TextDecoder().decode(payload));\n\n        // Filter out audio messages for WebRTC - they're handled via audio tracks\n        if (message.type === \"audio\") {\n          return;\n        }\n\n        if (isValidSocketEvent(message)) {\n          this.handleMessage(message);\n        } else {\n          console.warn(\"Invalid socket event received:\", message);\n        }\n      } catch (error) {\n        console.warn(\"Failed to parse incoming data message:\", error);\n        console.warn(\"Raw payload:\", new TextDecoder().decode(payload));\n      }\n    });\n\n    this.room.on(\n      RoomEvent.TrackSubscribed,\n      async (\n        track: Track,\n        publication: TrackPublication,\n        participant: Participant\n      ) => {\n        if (\n          track.kind === Track.Kind.Audio &&\n          participant.identity.includes(\"agent\")\n        ) {\n          // Play the audio track\n          const remoteAudioTrack = track as RemoteAudioTrack;\n          const audioElement = remoteAudioTrack.attach();\n          audioElement.autoplay = true;\n          audioElement.controls = false;\n\n          // Add to DOM (hidden) to ensure it plays\n          audioElement.style.display = \"none\";\n          document.body.appendChild(audioElement);\n        }\n      }\n    );\n  }\n\n  public close() {\n    if (this.isConnected) {\n      this.room.disconnect();\n    }\n  }\n\n  public async sendMessage(message: OutgoingSocketEvent) {\n    if (!this.isConnected || !this.room.localParticipant) {\n      console.warn(\n        \"Cannot send message: room not connected or no local participant\"\n      );\n      return;\n    }\n\n    // In WebRTC mode, audio is sent via published tracks, not data messages\n    if (\"user_audio_chunk\" in message) {\n      // Ignore audio data messages - audio flows through WebRTC tracks\n      return;\n    }\n\n    try {\n      const encoder = new TextEncoder();\n      const data = encoder.encode(JSON.stringify(message));\n\n      await this.room.localParticipant.publishData(data, { reliable: true });\n    } catch (error) {\n      this.debug({\n        type: \"send_message_error\",\n        message: {\n          message,\n          error,\n        },\n      });\n      console.error(\"Failed to send message via WebRTC:\", error);\n    }\n  }\n\n  // Get the room instance for advanced usage\n  public getRoom(): Room {\n    return this.room;\n  }\n}\n","import type {\n  BaseConnection,\n  SessionConfig,\n  ConnectionType,\n} from \"./BaseConnection\";\nimport { WebSocketConnection } from \"./WebSocketConnection\";\nimport { WebRTCConnection } from \"./WebRTCConnection\";\n\nfunction determineConnectionType(config: SessionConfig): ConnectionType {\n  // If connectionType is explicitly specified, use it\n  if (config.connectionType) {\n    return config.connectionType;\n  }\n\n  // If conversationToken is provided, use WebRTC\n  if (\"conversationToken\" in config && config.conversationToken) {\n    return \"webrtc\";\n  }\n\n  // Default to WebSocket for backward compatibility\n  return \"websocket\";\n}\n\nexport async function createConnection(\n  config: SessionConfig\n): Promise<BaseConnection> {\n  const connectionType = determineConnectionType(config);\n\n  switch (connectionType) {\n    case \"websocket\":\n      return WebSocketConnection.create(config);\n    case \"webrtc\":\n      return WebRTCConnection.create(config);\n    default:\n      throw new Error(`Unknown connection type: ${connectionType}`);\n  }\n}\n","export function isIosDevice() {\n  return (\n    [\n      \"iPad Simulator\",\n      \"iPhone Simulator\",\n      \"iPod Simulator\",\n      \"iPad\",\n      \"iPhone\",\n      \"iPod\",\n    ].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document)\n  );\n}\n\nexport function isAndroidDevice() {\n  return /android/i.test(navigator.userAgent);\n}\n","import { isAndroidDevice, isIosDevice } from \"./compatibility\";\nimport type { DelayConfig } from \"./connection\";\n\nexport async function applyDelay(\n  delayConfig: DelayConfig = {\n    default: 0,\n    // Give the Android AudioManager enough time to switch to the correct audio mode\n    android: 3_000,\n  }\n) {\n  let delay = delayConfig.default;\n  if (isAndroidDevice()) {\n    delay = delayConfig.android ?? delay;\n  } else if (isIosDevice()) {\n    delay = delayConfig.ios ?? delay;\n  }\n\n  if (delay > 0) {\n    await new Promise(resolve => setTimeout(resolve, delay));\n  }\n}\n","import { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection } from \"./utils/BaseConnection\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport { BaseConversation, type PartialOptions } from \"./BaseConversation\";\n\nexport class TextConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<TextConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let connection: BaseConnection | null = null;\n    try {\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      return new TextConversation(fullOptions, connection);\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      connection?.close();\n      throw error;\n    }\n  }\n}\n","export function arrayBufferToBase64(b: ArrayBufferLike) {\n  const buffer = new Uint8Array(b);\n  // @ts-ignore\n  const base64Data = window.btoa(String.fromCharCode(...buffer));\n  return base64Data;\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n}\n","const URLCache = new Map<string, string>();\n\nexport function createWorkletModuleLoader(name: string, sourceCode: string) {\n  return async (worklet: AudioWorklet) => {\n    const url = URLCache.get(name);\n    if (url) {\n      return worklet.addModule(url);\n    }\n\n    const blob = new Blob([sourceCode], { type: \"application/javascript\" });\n    const blobURL = URL.createObjectURL(blob);\n    try {\n      await worklet.addModule(blobURL);\n      URLCache.set(name, blobURL);\n      return;\n    } catch {\n      URL.revokeObjectURL(blobURL);\n    }\n\n    try {\n      // Attempting to start a conversation in Safari inside an iframe will\n      // throw a CORS error because the blob:// protocol is considered\n      // cross-origin. In such cases, fall back to using a base64 data URL:\n      const base64 = btoa(sourceCode);\n      const moduleURL = `data:application/javascript;base64,${base64}`;\n      await worklet.addModule(moduleURL);\n      URLCache.set(name, moduleURL);\n    } catch (error) {\n      throw new Error(\n        `Failed to load the ${name} worklet module. Make sure the browser supports AudioWorklets.`\n      );\n    }\n  };\n}\n","/*\n * ulaw encoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadRawAudioProcessor = createWorkletModuleLoader(\n  \"raw-audio-processor\",\n  // language=JavaScript\n  `\nconst BIAS = 0x84;\nconst CLIP = 32635;\nconst encodeTable = [\n  0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,\n  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7\n];\n\nfunction encodeSample(sample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let muLawSample;\n  sign = (sample >> 8) & 0x80;\n  if (sign !== 0) sample = -sample;\n  sample = sample + BIAS;\n  if (sample > CLIP) sample = CLIP;\n  exponent = encodeTable[(sample>>7) & 0xFF];\n  mantissa = (sample >> (exponent+3)) & 0x0F;\n  muLawSample = ~(sign | (exponent << 4) | mantissa);\n  \n  return muLawSample;\n}\n\nclass RawAudioProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n              \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.isMuted = false;\n          this.buffer = []; // Initialize an empty buffer\n          this.bufferSize = data.sampleRate / 4;\n          this.format = data.format;\n\n          if (globalThis.LibSampleRate && sampleRate !== data.sampleRate) {\n            globalThis.LibSampleRate.create(1, sampleRate, data.sampleRate).then(resampler => {\n              this.resampler = resampler;\n            });\n          }\n          break;\n        case \"setMuted\":\n          this.isMuted = data.isMuted;\n          break;\n      }\n    };\n  }\n  process(inputs) {\n    if (!this.buffer) {\n      return true;\n    }\n    \n    const input = inputs[0]; // Get the first input node\n    if (input.length > 0) {\n      let channelData = input[0]; // Get the first channel's data\n\n      // Resample the audio if necessary\n      if (this.resampler) {\n        channelData = this.resampler.full(channelData);\n      }\n\n      // Add channel data to the buffer\n      this.buffer.push(...channelData);\n      // Get max volume \n      let sum = 0.0;\n      for (let i = 0; i < channelData.length; i++) {\n        sum += channelData[i] * channelData[i];\n      }\n      const maxVolume = Math.sqrt(sum / channelData.length);\n      // Check if buffer size has reached or exceeded the threshold\n      if (this.buffer.length >= this.bufferSize) {\n        const float32Array = this.isMuted \n          ? new Float32Array(this.buffer.length)\n          : new Float32Array(this.buffer);\n\n        let encodedArray = this.format === \"ulaw\"\n          ? new Uint8Array(float32Array.length)\n          : new Int16Array(float32Array.length);\n\n        // Iterate through the Float32Array and convert each sample to PCM16\n        for (let i = 0; i < float32Array.length; i++) {\n          // Clamp the value to the range [-1, 1]\n          let sample = Math.max(-1, Math.min(1, float32Array[i]));\n\n          // Scale the sample to the range [-32768, 32767]\n          let value = sample < 0 ? sample * 32768 : sample * 32767;\n          if (this.format === \"ulaw\") {\n            value = encodeSample(Math.round(value));\n          }\n\n          encodedArray[i] = value;\n        }\n\n        // Send the buffered data to the main script\n        this.port.postMessage([encodedArray, maxVolume]);\n\n        // Clear the buffer after sending\n        this.buffer = [];\n      }\n    }\n    return true; // Continue processing\n  }\n}\nregisterProcessor(\"raw-audio-processor\", RawAudioProcessor);\n`\n);\n","import { loadRawAudioProcessor } from \"./rawAudioProcessor\";\nimport type { FormatConfig } from \"./connection\";\nimport { isIosDevice } from \"./compatibility\";\n\nexport type InputConfig = {\n  preferHeadphonesForIosDevices?: boolean;\n};\n\nconst LIBSAMPLERATE_JS =\n  \"https://cdn.jsdelivr.net/npm/@alexanderolsen/libsamplerate-js@2.1.2/dist/libsamplerate.worklet.js\";\n\nexport class Input {\n  public static async create({\n    sampleRate,\n    format,\n    preferHeadphonesForIosDevices,\n  }: FormatConfig & InputConfig): Promise<Input> {\n    let context: AudioContext | null = null;\n    let inputStream: MediaStream | null = null;\n\n    try {\n      const options: MediaTrackConstraints = {\n        sampleRate: { ideal: sampleRate },\n        echoCancellation: { ideal: true },\n        noiseSuppression: { ideal: true },\n      };\n\n      if (isIosDevice() && preferHeadphonesForIosDevices) {\n        const availableDevices =\n          await window.navigator.mediaDevices.enumerateDevices();\n        const idealDevice = availableDevices.find(\n          d =>\n            // cautious to include \"bluetooth\" in the search\n            // as might trigger bluetooth speakers\n            d.kind === \"audioinput\" &&\n            [\"airpod\", \"headphone\", \"earphone\"].find(keyword =>\n              d.label.toLowerCase().includes(keyword)\n            )\n        );\n        if (idealDevice) {\n          options.deviceId = { ideal: idealDevice.deviceId };\n        }\n      }\n\n      const supportsSampleRateConstraint =\n        navigator.mediaDevices.getSupportedConstraints().sampleRate;\n\n      context = new window.AudioContext(\n        supportsSampleRateConstraint ? { sampleRate } : {}\n      );\n      const analyser = context.createAnalyser();\n      if (!supportsSampleRateConstraint) {\n        await context.audioWorklet.addModule(LIBSAMPLERATE_JS);\n      }\n      await loadRawAudioProcessor(context.audioWorklet);\n\n      inputStream = await navigator.mediaDevices.getUserMedia({\n        audio: options,\n      });\n\n      const source = context.createMediaStreamSource(inputStream);\n      const worklet = new AudioWorkletNode(context, \"raw-audio-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format, sampleRate });\n\n      source.connect(analyser);\n      analyser.connect(worklet);\n\n      await context.resume();\n\n      return new Input(context, analyser, worklet, inputStream);\n    } catch (error) {\n      inputStream?.getTracks().forEach(track => track.stop());\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly worklet: AudioWorkletNode,\n    public readonly inputStream: MediaStream\n  ) {}\n\n  public async close() {\n    this.inputStream.getTracks().forEach(track => track.stop());\n    await this.context.close();\n  }\n\n  public setMuted(isMuted: boolean) {\n    this.worklet.port.postMessage({ type: \"setMuted\", isMuted });\n  }\n}\n","/*\n * ulaw decoding logic taken from the wavefile library\n * https://github.com/rochars/wavefile/blob/master/lib/codecs/mulaw.js\n */\n\nimport { createWorkletModuleLoader } from \"./createWorkletModuleLoader\";\n\nexport const loadAudioConcatProcessor = createWorkletModuleLoader(\n  \"audio-concat-processor\",\n  // language=JavaScript\n  `\nconst decodeTable = [0,132,396,924,1980,4092,8316,16764];\n\nexport function decodeSample(muLawSample) {\n  let sign;\n  let exponent;\n  let mantissa;\n  let sample;\n  muLawSample = ~muLawSample;\n  sign = (muLawSample & 0x80);\n  exponent = (muLawSample >> 4) & 0x07;\n  mantissa = muLawSample & 0x0F;\n  sample = decodeTable[exponent] + (mantissa << (exponent+3));\n  if (sign !== 0) sample = -sample;\n\n  return sample;\n}\n\nclass AudioConcatProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.buffers = []; // Initialize an empty buffer\n    this.cursor = 0;\n    this.currentBuffer = null;\n    this.wasInterrupted = false;\n    this.finished = false;\n    \n    this.port.onmessage = ({ data }) => {\n      switch (data.type) {\n        case \"setFormat\":\n          this.format = data.format;\n          break;\n        case \"buffer\":\n          this.wasInterrupted = false;\n          this.buffers.push(\n            this.format === \"ulaw\"\n              ? new Uint8Array(data.buffer)\n              : new Int16Array(data.buffer)\n          );\n          break;\n        case \"interrupt\":\n          this.wasInterrupted = true;\n          break;\n        case \"clearInterrupted\":\n          if (this.wasInterrupted) {\n            this.wasInterrupted = false;\n            this.buffers = [];\n            this.currentBuffer = null;\n          }\n      }\n    };\n  }\n  process(_, outputs) {\n    let finished = false;\n    const output = outputs[0][0];\n    for (let i = 0; i < output.length; i++) {\n      if (!this.currentBuffer) {\n        if (this.buffers.length === 0) {\n          finished = true;\n          break;\n        }\n        this.currentBuffer = this.buffers.shift();\n        this.cursor = 0;\n      }\n\n      let value = this.currentBuffer[this.cursor];\n      if (this.format === \"ulaw\") {\n        value = decodeSample(value);\n      }\n      output[i] = value / 32768;\n      this.cursor++;\n\n      if (this.cursor >= this.currentBuffer.length) {\n        this.currentBuffer = null;\n      }\n    }\n\n    if (this.finished !== finished) {\n      this.finished = finished;\n      this.port.postMessage({ type: \"process\", finished });\n    }\n\n    return true; // Continue processing\n  }\n}\n\nregisterProcessor(\"audio-concat-processor\", AudioConcatProcessor);\n`\n);\n","import { loadAudioConcatProcessor } from \"./audioConcatProcessor\";\nimport type { FormatConfig } from \"./connection\";\n\nexport class Output {\n  public static async create({\n    sampleRate,\n    format,\n  }: FormatConfig): Promise<Output> {\n    let context: AudioContext | null = null;\n    try {\n      context = new AudioContext({ sampleRate });\n      const analyser = context.createAnalyser();\n      const gain = context.createGain();\n      gain.connect(analyser);\n      analyser.connect(context.destination);\n      await loadAudioConcatProcessor(context.audioWorklet);\n      const worklet = new AudioWorkletNode(context, \"audio-concat-processor\");\n      worklet.port.postMessage({ type: \"setFormat\", format });\n      worklet.connect(gain);\n\n      await context.resume();\n\n      return new Output(context, analyser, gain, worklet);\n    } catch (error) {\n      context?.close();\n      throw error;\n    }\n  }\n\n  private constructor(\n    public readonly context: AudioContext,\n    public readonly analyser: AnalyserNode,\n    public readonly gain: GainNode,\n    public readonly worklet: AudioWorkletNode\n  ) {}\n\n  public async close() {\n    await this.context.close();\n  }\n}\n","import { arrayBufferToBase64, base64ToArrayBuffer } from \"./utils/audio\";\nimport { Input } from \"./utils/input\";\nimport { Output } from \"./utils/output\";\nimport { createConnection } from \"./utils/ConnectionFactory\";\nimport type { BaseConnection } from \"./utils/BaseConnection\";\nimport type { AgentAudioEvent, InterruptionEvent } from \"./utils/events\";\nimport { applyDelay } from \"./utils/applyDelay\";\nimport {\n  BaseConversation,\n  type Options,\n  type PartialOptions,\n} from \"./BaseConversation\";\n\nexport class VoiceConversation extends BaseConversation {\n  public static async startSession(\n    options: PartialOptions\n  ): Promise<VoiceConversation> {\n    const fullOptions = BaseConversation.getFullOptions(options);\n\n    fullOptions.onStatusChange({ status: \"connecting\" });\n    fullOptions.onCanSendFeedbackChange({ canSendFeedback: false });\n\n    let input: Input | null = null;\n    let connection: BaseConnection | null = null;\n    let output: Output | null = null;\n    let preliminaryInputStream: MediaStream | null = null;\n\n    let wakeLock: WakeLockSentinel | null = null;\n    if (options.useWakeLock ?? true) {\n      try {\n        wakeLock = await navigator.wakeLock.request(\"screen\");\n      } catch (e) {\n        // Wake Lock is not required for the conversation to work\n      }\n    }\n\n    try {\n      // some browsers won't allow calling getSupportedConstraints or enumerateDevices\n      // before getting approval for microphone access\n      preliminaryInputStream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n      });\n\n      await applyDelay(fullOptions.connectionDelay);\n      connection = await createConnection(options);\n      [input, output] = await Promise.all([\n        Input.create({\n          ...connection.inputFormat,\n          preferHeadphonesForIosDevices: options.preferHeadphonesForIosDevices,\n        }),\n        Output.create(connection.outputFormat),\n      ]);\n\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      preliminaryInputStream = null;\n\n      return new VoiceConversation(\n        fullOptions,\n        connection,\n        input,\n        output,\n        wakeLock\n      );\n    } catch (error) {\n      fullOptions.onStatusChange({ status: \"disconnected\" });\n      preliminaryInputStream?.getTracks().forEach(track => track.stop());\n      connection?.close();\n      await input?.close();\n      await output?.close();\n      try {\n        await wakeLock?.release();\n        wakeLock = null;\n      } catch (e) {}\n      throw error;\n    }\n  }\n\n  private inputFrequencyData?: Uint8Array;\n  private outputFrequencyData?: Uint8Array;\n\n  protected constructor(\n    options: Options,\n    connection: BaseConnection,\n    public readonly input: Input,\n    public readonly output: Output,\n    public wakeLock: WakeLockSentinel | null\n  ) {\n    super(options, connection);\n    this.input.worklet.port.onmessage = this.onInputWorkletMessage;\n    this.output.worklet.port.onmessage = this.onOutputWorkletMessage;\n  }\n\n  protected override async handleEndSession() {\n    await super.handleEndSession();\n    try {\n      await this.wakeLock?.release();\n      this.wakeLock = null;\n    } catch (e) {}\n\n    await this.input.close();\n    await this.output.close();\n  }\n\n  protected override handleInterruption(event: InterruptionEvent) {\n    super.handleInterruption(event);\n    this.fadeOutAudio();\n  }\n\n  protected override handleAudio(event: AgentAudioEvent) {\n    if (this.lastInterruptTimestamp <= event.audio_event.event_id) {\n      this.options.onAudio(event.audio_event.audio_base_64);\n      this.addAudioBase64Chunk(event.audio_event.audio_base_64);\n      this.currentEventId = event.audio_event.event_id;\n      this.updateCanSendFeedback();\n      this.updateMode(\"speaking\");\n    }\n  }\n\n  private onInputWorkletMessage = (event: MessageEvent): void => {\n    const rawAudioPcmData = event.data[0];\n\n    // TODO: When supported, maxVolume can be used to avoid sending silent audio\n    // const maxVolume = event.data[1];\n\n    if (this.status === \"connected\") {\n      this.connection.sendMessage({\n        user_audio_chunk: arrayBufferToBase64(rawAudioPcmData.buffer),\n      });\n    }\n  };\n\n  private onOutputWorkletMessage = ({ data }: MessageEvent): void => {\n    if (data.type === \"process\") {\n      this.updateMode(data.finished ? \"listening\" : \"speaking\");\n    }\n  };\n\n  private addAudioBase64Chunk = (chunk: string) => {\n    this.output.gain.gain.value = this.volume;\n    this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    this.output.worklet.port.postMessage({\n      type: \"buffer\",\n      buffer: base64ToArrayBuffer(chunk),\n    });\n  };\n\n  private fadeOutAudio = () => {\n    // mute agent\n    this.updateMode(\"listening\");\n    this.output.worklet.port.postMessage({ type: \"interrupt\" });\n    this.output.gain.gain.exponentialRampToValueAtTime(\n      0.0001,\n      this.output.context.currentTime + 2\n    );\n\n    // reset volume back\n    setTimeout(() => {\n      this.output.gain.gain.value = this.volume;\n      this.output.worklet.port.postMessage({ type: \"clearInterrupted\" });\n    }, 2000); // Adjust the duration as needed\n  };\n\n  private calculateVolume = (frequencyData: Uint8Array) => {\n    if (frequencyData.length === 0) {\n      return 0;\n    }\n\n    // TODO: Currently this averages all frequencies, but we should probably\n    // bias towards the frequencies that are more typical for human voice\n    let volume = 0;\n    for (let i = 0; i < frequencyData.length; i++) {\n      volume += frequencyData[i] / 255;\n    }\n    volume /= frequencyData.length;\n\n    return volume < 0 ? 0 : volume > 1 ? 1 : volume;\n  };\n\n  public setMicMuted(isMuted: boolean) {\n    this.input.setMuted(isMuted);\n  }\n\n  public getInputByteFrequencyData() {\n    this.inputFrequencyData ??= new Uint8Array(\n      this.input.analyser.frequencyBinCount\n    );\n    this.input.analyser.getByteFrequencyData(this.inputFrequencyData);\n    return this.inputFrequencyData;\n  }\n\n  public getOutputByteFrequencyData() {\n    this.outputFrequencyData ??= new Uint8Array(\n      this.output.analyser.frequencyBinCount\n    );\n    this.output.analyser.getByteFrequencyData(this.outputFrequencyData);\n    return this.outputFrequencyData;\n  }\n\n  public getInputVolume() {\n    return this.calculateVolume(this.getInputByteFrequencyData());\n  }\n\n  public getOutputVolume() {\n    return this.calculateVolume(this.getOutputByteFrequencyData());\n  }\n}\n","const HTTPS_API_ORIGIN = \"https://api.elevenlabs.io\";\n\nexport function postOverallFeedback(\n  conversationId: string,\n  like: boolean,\n  origin: string = HTTPS_API_ORIGIN\n) {\n  return fetch(`${origin}/v1/convai/conversations/${conversationId}/feedback`, {\n    method: \"POST\",\n    body: JSON.stringify({\n      feedback: like ? \"like\" : \"dislike\",\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  });\n}\n","import { BaseConversation, type PartialOptions } from \"./BaseConversation\";\nimport { TextConversation } from \"./TextConversation\";\nimport { VoiceConversation } from \"./VoiceConversation\";\n\nexport type {\n  Mode,\n  Role,\n  Options,\n  PartialOptions,\n  ClientToolsConfig,\n  Callbacks,\n  Status,\n} from \"./BaseConversation\";\nexport type { InputConfig } from \"./utils/input\";\nexport type { IncomingSocketEvent } from \"./utils/events\";\nexport type {\n  SessionConfig,\n  DisconnectionDetails,\n  Language,\n  ConnectionType,\n} from \"./utils/BaseConnection\";\nexport { createConnection } from \"./utils/ConnectionFactory\";\nexport { WebSocketConnection } from \"./utils/WebSocketConnection\";\nexport { WebRTCConnection } from \"./utils/WebRTCConnection\";\nexport { postOverallFeedback } from \"./utils/postOverallFeedback\";\n\nexport class Conversation extends BaseConversation {\n  public static startSession(options: PartialOptions): Promise<Conversation> {\n    return options.textOnly\n      ? TextConversation.startSession(options)\n      : VoiceConversation.startSession(options);\n  }\n}\n"],"names":["EMPTY_FREQUENCY_DATA","Uint8Array","BaseConversation","getFullOptions","partialOptions","_extends","clientTools","onConnect","onDebug","onDisconnect","onError","onMessage","onAudio","onModeChange","onStatusChange","onCanSendFeedbackChange","constructor","options","connection","_this","lastInterruptTimestamp","this","mode","status","volume","currentEventId","lastFeedbackEventId","canSendFeedback","endSessionWithDetails","async","details","updateStatus","handleEndSession","parsedEvent","type","handleInterruption","handleAgentResponse","handleUserTranscript","handleTentativeAgentResponse","handleClientToolCall","handleAudio","sendMessage","event_id","ping_event","setVolume","conversationId","endSession","reason","close","updateMode","updateCanSendFeedback","event","interruption_event","source","message","agent_response_event","agent_response","user_transcription_event","user_transcript","response","tentative_agent_response_internal_event","tentative_agent_response","Object","prototype","hasOwnProperty","call","client_tool_call","tool_name","_await$this$options$c","result","parameters","formattedResult","JSON","stringify","String","tool_call_id","is_error","e","clientToolName","onUnhandledClientToolCall","context","console","error","getId","isOpen","setMicMuted","isMuted","getInputByteFrequencyData","getOutputByteFrequencyData","getInputVolume","getOutputVolume","sendFeedback","like","score","warn","sendContextualUpdate","text","sendUserMessage","sendUserActivity","sendMCPToolApprovalResult","toolCallId","isApproved","is_approved","BaseConnection","config","queue","disconnectionDetails","onDisconnectCallback","onMessageCallback","debug","info","callback","length","queueMicrotask","forEach","disconnect","_this$onDisconnectCal","handleMessage","push","parseFormat","format","formatPart","sampleRatePart","split","includes","Error","sampleRate","Number","parseInt","isNaN","isValidSocketEvent","CONVERSATION_INITIATION_CLIENT_DATA_TYPE","constructOverrides","overridesEvent","_config$overrides$age","_config$overrides$age2","_config$overrides$age3","_config$overrides$tts","_config$overrides$con","overrides","conversation_config_override","agent","prompt","first_message","firstMessage","language","tts","voice_id","voiceId","conversation","text_only","textOnly","customLlmExtraBody","custom_llm_extra_body","dynamicVariables","dynamic_variables","userId","user_id","WebSocketConnection","socket","inputFormat","outputFormat","super","addEventListener","setTimeout","code","parse","data","_","create","_config$origin","origin","url","signedUrl","agentId","protocols","authorization","WebSocket","conversationConfig","Promise","resolve","reject","_socket","send","once","conversation_initiation_metadata_event","conversation_id","agent_output_audio_format","user_input_audio_format","_socket2","WebRTCConnection","room","isConnected","setupRoomEventListeners","conversationToken","fetch","ok","statusText","json","token","msg","Room","Date","now","livekitUrl","connect","onConnected","off","RoomEvent","Connected","on","name","localParticipant","setMicrophoneEnabled","Disconnected","CloseEvent","toString","ConnectionStateChanged","state","ConnectionState","Event","DataReceived","payload","participant","TextDecoder","decode","TrackSubscribed","track","publication","kind","Track","Kind","Audio","identity","audioElement","attach","autoplay","controls","style","display","document","body","appendChild","TextEncoder","encode","publishData","reliable","getRoom","createConnection","connectionType","determineConnectionType","isIosDevice","navigator","platform","userAgent","applyDelay","delayConfig","default","android","delay","_delayConfig$android","test","_delayConfig$ios","ios","TextConversation","startSession","fullOptions","connectionDelay","_connection","arrayBufferToBase64","b","buffer","window","btoa","fromCharCode","base64ToArrayBuffer","base64","binaryString","atob","len","bytes","i","charCodeAt","URLCache","Map","createWorkletModuleLoader","sourceCode","get","worklet","addModule","blob","Blob","blobURL","URL","createObjectURL","set","_unused","revokeObjectURL","moduleURL","loadRawAudioProcessor","Input","preferHeadphonesForIosDevices","inputStream","ideal","echoCancellation","noiseSuppression","idealDevice","mediaDevices","enumerateDevices","find","d","keyword","label","toLowerCase","deviceId","supportsSampleRateConstraint","getSupportedConstraints","AudioContext","analyser","createAnalyser","audioWorklet","getUserMedia","audio","createMediaStreamSource","AudioWorkletNode","port","postMessage","resume","_inputStream","_context","getTracks","stop","setMuted","loadAudioConcatProcessor","Output","gain","createGain","destination","VoiceConversation","_options$useWakeLock","input","output","preliminaryInputStream","wakeLock","useWakeLock","request","_preliminaryInputStre","all","_preliminaryInputStre2","_input","_output","_wakeLock","release","inputFrequencyData","outputFrequencyData","onInputWorkletMessage","user_audio_chunk","onOutputWorkletMessage","finished","addAudioBase64Chunk","chunk","value","fadeOutAudio","exponentialRampToValueAtTime","currentTime","calculateVolume","frequencyData","onmessage","_this$wakeLock","audio_event","audio_base_64","_this$inputFrequencyD","frequencyBinCount","getByteFrequencyData","postOverallFeedback","method","feedback","headers","Conversation"],"mappings":"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"}